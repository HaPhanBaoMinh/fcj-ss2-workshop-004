[
{
	"uri": "//localhost:1313/3-store_data/3.1-create_dynamodb/",
	"title": "Create a Table in DynamoDB",
	"tags": [],
	"description": "",
	"content": "After our IoT devices send data to IoT Core, we will proceed to store this information. There are many ways to store this data; here, I will use DynamoDB to store it.\n1. Create a Table in DynamoDB Select Create table to create a new table.\n2. Fill in the Required Information Table name: The name of the table you want to create. Primary key: Choose the key type for the table; here I choose Partition key as device_id. Add sort key: If you want to add a sort key, select here; I will leave it as timestamp. Then proceed to select Create to create the table.\nWe now have the table as follows:\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.1-register_new_thing/",
	"title": "Device Registration",
	"tags": [],
	"description": "",
	"content": "The first step to using AWS IoT Core is registering a device. In our case, it\u0026rsquo;s the ESP32.\n1. Access AWS IoT Core and select Create thing. 2. Fill in the details of your device. In this example, I entered the following information: Besides the device name, you will see additional fields such as:\nThing type: Type of device. Thing group: Device group. Billing group: Billing group. Packages and versions: Version and package. These details help you manage your devices more efficiently, especially if you have many devices.\nHere, I enter the device name + device ID.\nAfterward, select Next.\n3. Create Certificates. To ensure the data sent and received is secure, we need to generate certificates for the device.\nHere, I choose Auto-generate a new certificate and then select Next.\n4. Attach a policy. We will create the policy later, so in this step, select Create thing.\n5. After creation, download the certificate files to your computer. "
},
{
	"uri": "//localhost:1313/",
	"title": "Introduction",
	"tags": [],
	"description": "",
	"content": "Predicting Temperature \u0026amp; Humidity from ESP32 Data via IoT Core 1. Overview In this article, we will explore how to use the ESP32 to measure temperature and humidity from a temperature and humidity sensor, then send the data to AWS IoT CORE and store it in DynamoDB. We will then use Lambda to normalize the data. Finally, we will use AWS SageMaker Canvas to make predictions about future temperature and humidity.\nThis lab can be applied in various fields such as agriculture, healthcare, industry, etc.\n2. Objectives Understand how to use the ESP32 to measure temperature and humidity from a temperature and humidity sensor. Understand how to send data to AWS IoT CORE and store it in DynamoDB. Understand how to use Lambda to normalize the data. Understand how to use AWS SageMaker Canvas to make predictions about future temperature and humidity. "
},
{
	"uri": "//localhost:1313/1-prepare_resource/",
	"title": "Preparation",
	"tags": [],
	"description": "",
	"content": "\nOverview Diagram The diagram above shows an overview of this lab.\nThe ESP32 will collect temperature and humidity data from the sensor. The ESP32 will send the collected information to the AWS IoT Core Service via the MQTT protocol with the corresponding topic. After receiving the information from the ESP32, AWS IoT Core will send that data to AWS Lambda for processing. AWS Lambda will store the received information in DynamoDB. After a certain period, we will use the data in DynamoDB to import into Amazon SageMaker Canvas to create graphs and predict temperature and humidity. Resource Information All setup information for Wokwi and code can be found here: Resources\n"
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.1-create_dataset/",
	"title": "Prepare Dataset",
	"tags": [],
	"description": "",
	"content": "Before we start building our machine learning model, we need to prepare the dataset for our model.\nUsing the sample data that we imported into DynamoDB, we will use this data to build the machine learning model.\nFirst, we need to export the data from DynamoDB to a CSV file as I instructed in step 4.\n1. Create Dataset We go to SageMaker and select Datasets, then choose Import data.\nWe select Tabular and proceed to choose the CSV file that we exported from DynamoDB.\nWe can preview the data before importing.\nProceed to Create dataset.\nCheck back on the Datasets page, and we see that we have successfully created the dataset.\n"
},
{
	"uri": "//localhost:1313/1-prepare_resource/1.1-esp34/",
	"title": "Setting Up ESP32",
	"tags": [],
	"description": "",
	"content": "\nWOKWI In this lab, we will use Wokwi to simulate collecting data from the DHT11 temperature and humidity sensor and sending the data to AWS IoT Core via the MQTT protocol.\nDevice Setup Once we have an account on Wokwi, we proceed to create a new project.\nGo to the Wokwi homepage: https://wokwi.com/ Log into your account. Create a new project by selecting New Project. Select ESP32 from the list of components. Select MicroPython. Select diagram.json and paste the following content: { \u0026#34;version\u0026#34;: 1, \u0026#34;author\u0026#34;: \u0026#34;Anonymous maker\u0026#34;, \u0026#34;editor\u0026#34;: \u0026#34;wokwi\u0026#34;, \u0026#34;parts\u0026#34;: [ { \u0026#34;type\u0026#34;: \u0026#34;wokwi-esp32-devkit-v1\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;esp\u0026#34;, \u0026#34;top\u0026#34;: 137.33, \u0026#34;left\u0026#34;: -18.01, \u0026#34;rotate\u0026#34;: 270, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-lcd1602\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;lcd1\u0026#34;, \u0026#34;top\u0026#34;: 18.67, \u0026#34;left\u0026#34;: 76, \u0026#34;attrs\u0026#34;: { \u0026#34;pins\u0026#34;: \u0026#34;i2c\u0026#34; } }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r1\u0026#34;, \u0026#34;top\u0026#34;: 113.34, \u0026#34;left\u0026#34;: -106.01, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-resistor\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;r2\u0026#34;, \u0026#34;top\u0026#34;: 130.67, \u0026#34;left\u0026#34;: -106.68, \u0026#34;attrs\u0026#34;: {} }, { \u0026#34;type\u0026#34;: \u0026#34;wokwi-dht22\u0026#34;, \u0026#34;id\u0026#34;: \u0026#34;dht1\u0026#34;, \u0026#34;top\u0026#34;: 182.7, \u0026#34;left\u0026#34;: 205.8, \u0026#34;attrs\u0026#34;: {} } ], \u0026#34;connections\u0026#34;: [ [ \u0026#34;esp:TX0\u0026#34;, \u0026#34;$serialMonitor:RX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;esp:RX0\u0026#34;, \u0026#34;$serialMonitor:TX\u0026#34;, \u0026#34;\u0026#34;, [] ], [ \u0026#34;lcd1:SCL\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:SDA\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;h0\u0026#34; ] ], [ \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;h-30\u0026#34;, \u0026#34;v103\u0026#34;, \u0026#34;h41\u0026#34; ] ], [ \u0026#34;lcd1:GND\u0026#34;, \u0026#34;esp:GND.1\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;h-39\u0026#34;, \u0026#34;v123\u0026#34;, \u0026#34;h31\u0026#34; ] ], [ \u0026#34;r2:2\u0026#34;, \u0026#34;esp:D22\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v1\u0026#34;, \u0026#34;h9\u0026#34; ] ], [ \u0026#34;r1:2\u0026#34;, \u0026#34;esp:D21\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h37\u0026#34; ] ], [ \u0026#34;r2:1\u0026#34;, \u0026#34;r1:1\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;r1:1\u0026#34;, \u0026#34;lcd1:VCC\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v0\u0026#34; ] ], [ \u0026#34;dht1:VCC\u0026#34;, \u0026#34;esp:3V3\u0026#34;, \u0026#34;red\u0026#34;, [ \u0026#34;v0\u0026#34;, \u0026#34;h-19.2\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-105.6\u0026#34; ] ], [ \u0026#34;dht1:SDA\u0026#34;, \u0026#34;esp:D15\u0026#34;, \u0026#34;green\u0026#34;, [ \u0026#34;v9.6\u0026#34;, \u0026#34;h-38.3\u0026#34;, \u0026#34;v-134.4\u0026#34;, \u0026#34;h-119.01\u0026#34; ] ], [ \u0026#34;dht1:GND\u0026#34;, \u0026#34;esp:GND.2\u0026#34;, \u0026#34;black\u0026#34;, [ \u0026#34;v19.2\u0026#34;, \u0026#34;h-172.8\u0026#34; ] ] ], \u0026#34;dependencies\u0026#34;: {} } Result: "
},
{
	"uri": "//localhost:1313/2-aws_iot_core/",
	"title": "AWS IoT Core",
	"tags": [],
	"description": "",
	"content": "\nAWS IoT Core is a service that provides functionalities to connect IoT devices with other AWS services.\nIoT Core supports multiple connection protocols, including:\n1. MQTT (Message Queuing and Telemetry Transport)\n2. MQTT over WSS (Websockets Secure)\n3. WebSockets\n4. HTTPS (Hypertext Transfer Protocol - Secure)\n5. LoRaWAN (Long Range Wide Area Network)\nWays to connect devices to IoT Core:\nAWS IoT Device SDK AWS IoT Core for LoRaWAN AWS Command Line Interface (CLI) AWS IoT API AWS SDKs Additionally, you can directly send messages to the message broker on the AWS Console.\n"
},
{
	"uri": "//localhost:1313/3-store_data/3.2-create_lambda/",
	"title": "Create Lambda",
	"tags": [],
	"description": "",
	"content": "We will create a lambda function to process the data before storing it in DynamoDB.\n1. Create Lambda Function Access Lambda on the AWS console. Select Create function to create a new lambda function. 2. Fill in the Required Information Function name: The name of the lambda function. Runtime: Choose the runtime for the lambda function; here I select Python 3.11. Then select Create function to create the lambda function. 3. Update the Role of the Lambda Function For the lambda function to access DynamoDB, we need to update the role of the lambda function.\nWe can click here to navigate to the IAM role page of the lambda function. 4. Add Policy Here we will add a new policy for the lambda function. To make it easier, we will select the policy AmazonDynamoDBFullAccess. 5. Update Code for the Lambda Function We will update the code for the lambda function as follows: import json import boto3 from botocore.exceptions import ClientError # Initialize DynamoDB dynamodb = boto3.resource(\u0026#39;dynamodb\u0026#39;) table = dynamodb.Table(\u0026#39;ESP32-Temperature-Humidity\u0026#39;) def lambda_handler(event, context): try: # Retrieve data from event device_id = event[\u0026#39;device_id\u0026#39;] temperature = event[\u0026#39;temp\u0026#39;] humidity = event[\u0026#39;humidity\u0026#39;] timestamp = event[\u0026#39;timestamp\u0026#39;] # Save data to DynamoDB response = table.put_item( Item={ \u0026#39;device_id\u0026#39;: device_id, \u0026#39;temperature\u0026#39;: temperature, \u0026#39;humidity\u0026#39;: humidity, \u0026#39;timestamp\u0026#39;: timestamp } ) print(\u0026#34;Data saved successfully:\u0026#34;, response) return { \u0026#39;statusCode\u0026#39;: 200, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Data saved successfully\u0026#39;) } except ClientError as e: print(\u0026#34;Error saving data:\u0026#34;, e) return { \u0026#39;statusCode\u0026#39;: 500, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Error saving data\u0026#39;) } except KeyError as e: print(\u0026#34;Missing key in event:\u0026#34;, e) return { \u0026#39;statusCode\u0026#39;: 400, \u0026#39;body\u0026#39;: json.dumps(\u0026#39;Missing key in event\u0026#39;) } "
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.2-create_model/",
	"title": "Create Model",
	"tags": [],
	"description": "",
	"content": "OK, now we will create a model from the data we collected in the previous step.\n1. Create Model We go to SageMaker and select My Models, then choose Create new model.\nNext, we name the model and select the Problem type as Predictive analysis.\nAnd proceed to create.\n2. Select Dataset We choose the dataset that we created in the previous step.\n3. Configure Model We proceed to select the parameters that will be used for the model.\nAdditionally, we will select the columns that will be predicted later.\nHere, we will predict the Temperature column.\nThen we proceed to select Quick build to create the model.\n4. Result We will have the result as follows:\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.2-create_policies/",
	"title": "Create Policy",
	"tags": [],
	"description": "",
	"content": "Next, we will create a policy so that the \u0026ldquo;things\u0026rdquo; we created in the previous step can access AWS IoT Core resources.\n1. Select Create a policy. 2. Fill in your policy details. Here, I entered the following information:\nPolicy Name: The name of the policy. Policy effect: Select Allow - to permit access. Policy action: Select iot:* - to allow all actions in AWS IoT Core. Resource ARN: Select All resources - to allow access to all resources in AWS IoT Core. Then select Create.\n3. After creating, you will see your policy. 4. Next, we will attach this policy to the certificate we created earlier. Go to Certificates and select Attach policy.\nSelect the policy you just created and choose Attach policies.\n5. After attaching, you will see the policy linked to the certificate. "
},
{
	"uri": "//localhost:1313/1-prepare_resource/1.2-library/",
	"title": "Required Libraries",
	"tags": [],
	"description": "",
	"content": "\nCode files for communicating with the screen. We create an i2c_lcd.py file: \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C. This was tested with: https://www.wemos.cc/product/d1-mini.html\u0026#34;\u0026#34;\u0026#34; from lcd_api import LcdApi from machine import I2C from time import sleep_ms # The PCF8574 has a jumper selectable address: 0x20 - 0x27 #DEFAULT_I2C_ADDR = 0x20 # Defines shifts or masks for the various LCD line attached to the PCF8574 MASK_RS = 0x01 MASK_RW = 0x02 MASK_E = 0x04 SHIFT_BACKLIGHT = 3 SHIFT_DATA = 4 class I2cLcd(LcdApi): \u0026#34;\u0026#34;\u0026#34;Implements a HD44780 character LCD connected via PCF8574 on I2C.\u0026#34;\u0026#34;\u0026#34; def __init__(self, i2c, i2c_addr, num_lines, num_columns): self.i2c = i2c self.i2c_addr = i2c_addr self.i2c.writeto(self.i2c_addr, bytearray([0])) sleep_ms(20) # Allow LCD time to powerup # Send reset 3 times self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(5) # need to delay at least 4.1 msec self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) self.hal_write_init_nibble(self.LCD_FUNCTION_RESET) sleep_ms(1) # Put LCD into 4 bit mode self.hal_write_init_nibble(self.LCD_FUNCTION) sleep_ms(1) LcdApi.__init__(self, num_lines, num_columns) cmd = self.LCD_FUNCTION if num_lines \u0026gt; 1: cmd |= self.LCD_FUNCTION_2LINES self.hal_write_command(cmd) def hal_write_init_nibble(self, nibble): \u0026#34;\u0026#34;\u0026#34;Writes an initialization nibble to the LCD. This particular function is only used during initialization. \u0026#34;\u0026#34;\u0026#34; byte = ((nibble \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([1 \u0026lt;\u0026lt; SHIFT_BACKLIGHT])) def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off.\u0026#34;\u0026#34;\u0026#34; self.i2c.writeto(self.i2c_addr, bytearray([0])) def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Writes a command to the LCD. Data is latched on the falling edge of E. \u0026#34;\u0026#34;\u0026#34; byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((cmd \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = ((self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((cmd \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) if cmd \u0026lt;= 3: # The home and clear commands require a worst case delay of 4.1 msec sleep_ms(5) def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD.\u0026#34;\u0026#34;\u0026#34; byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | (((data \u0026gt;\u0026gt; 4) \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) byte = (MASK_RS | (self.backlight \u0026lt;\u0026lt; SHIFT_BACKLIGHT) | ((data \u0026amp; 0x0f) \u0026lt;\u0026lt; SHIFT_DATA)) self.i2c.writeto(self.i2c_addr, bytearray([byte | MASK_E])) self.i2c.writeto(self.i2c_addr, bytearray([byte])) We create an lcd_api.py file: \u0026#34;\u0026#34;\u0026#34;Provides an API for talking to HD44780 compatible character LCDs.\u0026#34;\u0026#34;\u0026#34; import time class LcdApi: \u0026#34;\u0026#34;\u0026#34;Implements the API for talking with HD44780 compatible character LCDs. This class only knows what commands to send to the LCD, and not how to get them to the LCD. It is expected that a derived class will implement the hal_xxx functions. \u0026#34;\u0026#34;\u0026#34; # The following constant names were lifted from the avrlib lcd.h # header file, however, I changed the definitions from bit numbers # to bit masks. # # HD44780 LCD controller command set LCD_CLR = 0x01 # DB0: clear display LCD_HOME = 0x02 # DB1: return to home position LCD_ENTRY_MODE = 0x04 # DB2: set entry mode LCD_ENTRY_INC = 0x02 # --DB1: increment LCD_ENTRY_SHIFT = 0x01 # --DB0: shift LCD_ON_CTRL = 0x08 # DB3: turn lcd/cursor on LCD_ON_DISPLAY = 0x04 # --DB2: turn display on LCD_ON_CURSOR = 0x02 # --DB1: turn cursor on LCD_ON_BLINK = 0x01 # --DB0: blinking cursor LCD_MOVE = 0x10 # DB4: move cursor/display LCD_MOVE_DISP = 0x08 # --DB3: move display (0-\u0026gt; move cursor) LCD_MOVE_RIGHT = 0x04 # --DB2: move right (0-\u0026gt; left) LCD_FUNCTION = 0x20 # DB5: function set LCD_FUNCTION_8BIT = 0x10 # --DB4: set 8BIT mode (0-\u0026gt;4BIT mode) LCD_FUNCTION_2LINES = 0x08 # --DB3: two lines (0-\u0026gt;one line) LCD_FUNCTION_10DOTS = 0x04 # --DB2: 5x10 font (0-\u0026gt;5x7 font) LCD_FUNCTION_RESET = 0x30 # See \u0026#34;Initializing by Instruction\u0026#34; section LCD_CGRAM = 0x40 # DB6: set CG RAM address LCD_DDRAM = 0x80 # DB7: set DD RAM address LCD_RS_CMD = 0 LCD_RS_DATA = 1 LCD_RW_WRITE = 0 LCD_RW_READ = 1 def __init__(self, num_lines, num_columns): self.num_lines = num_lines if self.num_lines \u0026gt; 4: self.num_lines = 4 self.num_columns = num_columns if self.num_columns \u0026gt; 40: self.num_columns = 40 self.cursor_x = 0 self.cursor_y = 0 self.implied_newline = False self.backlight = True self.display_off() self.backlight_on() self.clear() self.hal_write_command(self.LCD_ENTRY_MODE | self.LCD_ENTRY_INC) self.hide_cursor() self.display_on() def clear(self): \u0026#34;\u0026#34;\u0026#34;Clears the LCD display and moves the cursor to the top left corner. \u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_CLR) self.hal_write_command(self.LCD_HOME) self.cursor_x = 0 self.cursor_y = 0 def show_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be made visible.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def hide_cursor(self): \u0026#34;\u0026#34;\u0026#34;Causes the cursor to be hidden.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def blink_cursor_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it blink.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR | self.LCD_ON_BLINK) def blink_cursor_off(self): \u0026#34;\u0026#34;\u0026#34;Turns on the cursor, and makes it no blink (i.e. be solid).\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY | self.LCD_ON_CURSOR) def display_on(self): \u0026#34;\u0026#34;\u0026#34;Turns on (i.e. unblanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL | self.LCD_ON_DISPLAY) def display_off(self): \u0026#34;\u0026#34;\u0026#34;Turns off (i.e. blanks) the LCD.\u0026#34;\u0026#34;\u0026#34; self.hal_write_command(self.LCD_ON_CTRL) def backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight on. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = True self.hal_backlight_on() def backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Turns the backlight off. This isn\u0026#39;t really an LCD command, but some modules have backlight controls, so this allows the hal to pass through the command. \u0026#34;\u0026#34;\u0026#34; self.backlight = False self.hal_backlight_off() def move_to(self, cursor_x, cursor_y): \u0026#34;\u0026#34;\u0026#34;Moves the cursor position to the indicated position. The cursor position is zero based (i.e. cursor_x == 0 indicates first column). \u0026#34;\u0026#34;\u0026#34; self.cursor_x = cursor_x self.cursor_y = cursor_y addr = cursor_x \u0026amp; 0x3f if cursor_y \u0026amp; 1: addr += 0x40 # Lines 1 \u0026amp; 3 add 0x40 if cursor_y \u0026amp; 2: # Lines 2 \u0026amp; 3 add number of columns addr += self.num_columns self.hal_write_command(self.LCD_DDRAM | addr) def putchar(self, char): \u0026#34;\u0026#34;\u0026#34;Writes the indicated character to the LCD at the current cursor position, and advances the cursor by one position. \u0026#34;\u0026#34;\u0026#34; if char == \u0026#39;\\n\u0026#39;: if self.implied_newline: # self.implied_newline means we advanced due to a wraparound, # so if we get a newline right after that we ignore it. pass else: self.cursor_x = self.num_columns else: self.hal_write_data(ord(char)) self.cursor_x += 1 if self.cursor_x \u0026gt;= self.num_columns: self.cursor_x = 0 self.cursor_y += 1 self.implied_newline = (char != \u0026#39;\\n\u0026#39;) if self.cursor_y \u0026gt;= self.num_lines: self.cursor_y = 0 self.move_to(self.cursor_x, self.cursor_y) def putstr(self, string): \u0026#34;\u0026#34;\u0026#34;Write the indicated string to the LCD at the current cursor position and advances the cursor position appropriately. \u0026#34;\u0026#34;\u0026#34; for char in string: self.putchar(char) def custom_char(self, location, charmap): \u0026#34;\u0026#34;\u0026#34;Write a character to one of the 8 CGRAM locations, available as chr(0) through chr(7). \u0026#34;\u0026#34;\u0026#34; location \u0026amp;= 0x7 self.hal_write_command(self.LCD_CGRAM | (location \u0026lt;\u0026lt; 3)) self.hal_sleep_us(40) for i in range(8): self.hal_write_data(charmap[i]) self.hal_sleep_us(40) self.move_to(self.cursor_x, self.cursor_y) def hal_backlight_on(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight on. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_backlight_off(self): \u0026#34;\u0026#34;\u0026#34;Allows the hal layer to turn the backlight off. If desired, a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; pass def hal_write_command(self, cmd): \u0026#34;\u0026#34;\u0026#34;Write a command to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_write_data(self, data): \u0026#34;\u0026#34;\u0026#34;Write data to the LCD. It is expected that a derived HAL class will implement this function. \u0026#34;\u0026#34;\u0026#34; raise NotImplementedError def hal_sleep_us(self, usecs): \u0026#34;\u0026#34;\u0026#34;Sleep for some time (given in microseconds).\u0026#34;\u0026#34;\u0026#34; time.sleep_us(usecs) We create an main.py for test: import network import time from machine import Pin, I2C import dht import ujson from umqtt.simple import MQTTClient from i2c_lcd import I2cLcd # Import the custom I2C_LCD class import ussl as ssl # MQTT Server Parameters MQTT_CLIENT_ID = \u0026#34;ESP32-001\u0026#34; MQTT_BROKER = \u0026#34;a23sutvtpz6muq-ats.iot.ap-southeast-1.amazonaws.com\u0026#34; MQTT_TOPIC = \u0026#34;test\u0026#34; # DHT22 sensor setup sensor = dht.DHT22(Pin(15)) # I2C and LCD setup (adjust the I2C address if necessary) i2c = I2C(0, sda=Pin(21), scl=Pin(22), freq=400000) # SDA to pin 27, SCL to pin 26 I2C_ADDR = 0x27 # Default I2C address for the LCD lcd = I2cLcd(i2c, I2C_ADDR, 2, 16) # Assuming a 16x2 LCD # Private key and certificate (paste the contents here as strings) key_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- \u0026#34;\u0026#34;\u0026#34; cert_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; ca_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; # WiFi connection print(\u0026#34;Connecting to WiFi\u0026#34;, end=\u0026#34;\u0026#34;) sta_if = network.WLAN(network.STA_IF) sta_if.active(True) sta_if.connect(\u0026#39;Wokwi-GUEST\u0026#39;, \u0026#39;\u0026#39;) while not sta_if.isconnected(): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) time.sleep(0.1) print(\u0026#34; Connected!\u0026#34;) # MQTT setup print(\u0026#34;Connecting to MQTT server... \u0026#34;, end=\u0026#34;\u0026#34;) ssl_params = { \u0026#39;key\u0026#39;: key_data, \u0026#39;cert\u0026#39;: cert_data, \u0026#39;cadata\u0026#39;:ca_data } client = MQTTClient( MQTT_CLIENT_ID, MQTT_BROKER, ssl=True, ssl_params=ssl_params, port=8883 ) client.connect() print(\u0026#34;Connected!\u0026#34;) # Display welcome message on LCD lcd.clear() lcd.putstr(\u0026#34;Weather Station\u0026#34;) time.sleep(2) prev_weather = \u0026#34;\u0026#34; while True: print(\u0026#34;Measuring weather conditions... \u0026#34;, end=\u0026#34;\u0026#34;) sensor.measure() temp = sensor.temperature() humidity = sensor.humidity() timestamp = time.time() # Format the message for MQTT message = ujson.dumps({ \u0026#34;temp\u0026#34;: temp, \u0026#34;humidity\u0026#34;: humidity, \u0026#34;device_id\u0026#34;: device_id, \u0026#34;timestamp\u0026#34;: timestamp }) # Display temperature and humidity on the LCD lcd.clear() lcd.putstr(\u0026#34;Temp: {:.1f} C\u0026#34;.format(temp)) lcd.move_to(0, 1) lcd.putstr(\u0026#34;Humidity: {:.1f}%\u0026#34;.format(humidity)) # Publish to MQTT if there is a change in the readings print(\u0026#34;Updated!\u0026#34;) print(\u0026#34;Reporting to MQTT topic {}: {}\u0026#34;.format(MQTT_TOPIC, message)) client.publish(MQTT_TOPIC, message) prev_weather = message time.sleep(30) # Wait for 5 seconds before taking the next reading "
},
{
	"uri": "//localhost:1313/3-store_data/3.3-create-iot_action/",
	"title": "Create IoT Rule and Action",
	"tags": [],
	"description": "",
	"content": "We will create an IoT rule and action to send information from IoT Core to the Lambda function.\n1. Create IoT Rule Access IoT Core on the AWS console. Select Message routing and then select Rules. Choose Create rule. 2. Fill in the Required Information Name: The name of the rule. Description: A description of the rule. Fill in the information for the query statement: In the Set one or more actions section, select Add action. Choose the Lambda function that we created in the previous step. Review the information and proceed to create the rule. At this point, when you return to the Lambda function page, you will see a new trigger created.\n"
},
{
	"uri": "//localhost:1313/3-store_data/",
	"title": "Data Storage",
	"tags": [],
	"description": "",
	"content": "\nNow that we have data from the device sent to AWS IoT Core, we will look for ways to store this data in DynamoDB.\nIn this section, we will cover the following:\nCreate a DynamoDB table. Create a Rule to store data in DynamoDB. Create a Lambda function to process the data before storing it in DynamoDB. Create an IoT Core Rule. "
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.3-test-client/",
	"title": "MQTT Test Client",
	"tags": [],
	"description": "",
	"content": "We will use the MQTT test client to test the connection between the device and AWS IoT Core.\n1. In the console screen, select MQTT test client. Here, we enter the topic as test and select Subscribe to topic.\nScroll down, and we will see a message display box. Currently, we haven\u0026rsquo;t received any messages.\nNow, we are listening to all messages from the test topic. Whenever a message is published to the test topic, we will receive that message.\n2. We will test by publishing a message to the test topic. We will send a message to the test topic with the content Hello from AWS IoT console and select Publish.\nAfter publishing, we will receive the message we just published in the Subscribe to a topic tab.\nOK, good job!\n"
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.3-prepare_dataset_for_predict/",
	"title": "Preparing Dataset for Prediction",
	"tags": [],
	"description": "",
	"content": "Now we have a model without having to write a single line of code. So cool!!!\nNext, we will prepare a dataset for predicting data from the model we created in the previous step. In this file, we will not have the Temperature column, as we will use the model to predict the value of this column.\n1. Prepare the Dataset This is the dataset file that we will use to predict the value of the Temperature column.\nSimilar to step 5.1, we will create a dataset from the CSV file we prepared.\nHere, I have created a new dataset from the CSV file named Predict_data.\n"
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/5.4-predict_data/",
	"title": "Making Predictions",
	"tags": [],
	"description": "",
	"content": "Now we have a model and a dataset to predict the value of the Temperature column.\n1. Prediction We access the model we created in the previous step and select Predict.\nHere we choose Manual.\nNext, we select the dataset we prepared in the previous step.\nThen we wait for the results.\n2. Results We will have results as follows:\nThe model has predicted the value of the Temperature column based on the model we created.\n3. Note: If we have a larger and more detailed dataset, the model will make more accurate predictions.\nIn this example, I only predicted the value of the Temperature column based on the value of Humidity.\nFrom this example, you can apply it to many different problems.\n"
},
{
	"uri": "//localhost:1313/2-aws_iot_core/2.4-test-esp32/",
	"title": "MQTT Test ESP32",
	"tags": [],
	"description": "",
	"content": "We will use the ESP32 to test the connection between the device and AWS IoT Core.\n1. First, we need to obtain the endpoint information of the MQTT broker. We go to the AWS shell and run the following command:\naws iot describe-endpoint We will receive information as follows:\nThis is the endpoint information of the MQTT broker that we will use to connect to AWS IoT Core.\n2. In the main.py file, we will fill in the cert information as follows: import network import time from machine import Pin, I2C import dht import ujson from umqtt.simple import MQTTClient from i2c_lcd import I2cLcd # Import the custom I2C_LCD class import ussl as ssl # MQTT Server Parameters MQTT_CLIENT_ID = \u0026#34;ESP32-001\u0026#34; MQTT_BROKER = \u0026#34;a23sutvtpz6muq-ats.iot.ap-southeast-1.amazonaws.com\u0026#34; MQTT_TOPIC = \u0026#34;test\u0026#34; # DHT22 sensor setup sensor = dht.DHT22(Pin(15)) # I2C and LCD setup (adjust the I2C address if necessary) i2c = I2C(0, sda=Pin(21), scl=Pin(22), freq=400000) # SDA to pin 27, SCL to pin 26 I2C_ADDR = 0x27 # Default I2C address for the LCD lcd = I2cLcd(i2c, I2C_ADDR, 2, 16) # Assuming a 16x2 LCD # Private key and certificate (paste the contents here as strings) key_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN RSA PRIVATE KEY----- -----END RSA PRIVATE KEY----- \u0026#34;\u0026#34;\u0026#34; cert_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; ca_data = \u0026#34;\u0026#34;\u0026#34; -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- \u0026#34;\u0026#34;\u0026#34; # WiFi connection print(\u0026#34;Connecting to WiFi\u0026#34;, end=\u0026#34;\u0026#34;) sta_if = network.WLAN(network.STA_IF) sta_if.active(True) sta_if.connect(\u0026#39;Wokwi-GUEST\u0026#39;, \u0026#39;\u0026#39;) while not sta_if.isconnected(): print(\u0026#34;.\u0026#34;, end=\u0026#34;\u0026#34;) time.sleep(0.1) print(\u0026#34; Connected!\u0026#34;) # MQTT setup print(\u0026#34;Connecting to MQTT server... \u0026#34;, end=\u0026#34;\u0026#34;) ssl_params = { \u0026#39;key\u0026#39;: key_data, \u0026#39;cert\u0026#39;: cert_data, \u0026#39;cadata\u0026#39;:ca_data } client = MQTTClient( MQTT_CLIENT_ID, MQTT_BROKER, ssl=True, ssl_params=ssl_params, port=8883 ) client.connect() print(\u0026#34;Connected!\u0026#34;) # Display welcome message on LCD lcd.clear() lcd.putstr(\u0026#34;Weather Station\u0026#34;) time.sleep(2) prev_weather = \u0026#34;\u0026#34; while True: print(\u0026#34;Measuring weather conditions... \u0026#34;, end=\u0026#34;\u0026#34;) sensor.measure() temp = sensor.temperature() humidity = sensor.humidity() timestamp = time.time() # Format the message for MQTT message = ujson.dumps({ \u0026#34;temp\u0026#34;: temp, \u0026#34;humidity\u0026#34;: humidity, \u0026#34;device_id\u0026#34;: device_id, \u0026#34;timestamp\u0026#34;: timestamp }) # Display temperature and humidity on the LCD lcd.clear() lcd.putstr(\u0026#34;Temp: {:.1f} C\u0026#34;.format(temp)) lcd.move_to(0, 1) lcd.putstr(\u0026#34;Humidity: {:.1f}%\u0026#34;.format(humidity)) # Publish to MQTT if there is a change in the readings print(\u0026#34;Updated!\u0026#34;) print(\u0026#34;Reporting to MQTT topic {}: {}\u0026#34;.format(MQTT_TOPIC, message)) client.publish(MQTT_TOPIC, message) prev_weather = message time.sleep(30) # Wait for 30 seconds before taking the next reading When we run the main.py file on the ESP32, we will see the temperature and humidity information displayed on the LCD and also published to the test topic on AWS IoT Core.\nWe check on the MQTT test client, and we will see the message published to the test topic. Good job!\nNow you can change the topic information and publish different messages to that topic.\n"
},
{
	"uri": "//localhost:1313/4-example_data/",
	"title": "Preparing Sample Data",
	"tags": [],
	"description": "",
	"content": "To make the data preparation process easier and save time, we will use some available sample data and proceed to import it into DynamoDB.\n1. Create an S3 Bucket First, we need to create an S3 bucket to store the sample data files.\nNext, we download the sample data file and upload it to the S3 bucket.\n2. Import Data into DynamoDB Next, we will import data from the S3 bucket into DynamoDB.\nWe go to DynamoDB and select Imports from S3.\nWe fill in the information as follows:\nAfter that, we proceed to import.\nAs a result, we create a table with sample data.\nAs you can see, we have sample data in DynamoDB.\n3. Export Data from DynamoDB We can also export data from DynamoDB to a CSV file to import the dataset into SageMaker.\nIn the Explore items section, after performing a Scan, we select Action and choose Download results to CSV.\n"
},
{
	"uri": "//localhost:1313/3-store_data/3.4-test/",
	"title": "Test",
	"tags": [],
	"description": "",
	"content": "It seems everything is set up correctly. Now let\u0026rsquo;s try powering on the ESP32 and see if the data gets saved to DynamoDB.\nWhen the ESP32 runs, the data will be sent to AWS IoT Core. AWS IoT Core will process the data and store it in DynamoDB. We will check if the data has been saved to DynamoDB. As you can see, the data has been saved to DynamoDB.\n"
},
{
	"uri": "//localhost:1313/5-sagemaker_canvas/",
	"title": "SageMaker Canvas",
	"tags": [],
	"description": "",
	"content": "\nAlright, now we come to the most exciting part of today\u0026rsquo;s lab. We will use SageMaker Canvas to build a machine learning model without writing any code.\n1. Create SageMaker Canvas First, we go to SageMaker and select SageMaker Canvas, then choose Create a SageMaker domain.\nAfter that, wait for AWS to create the domain for us.\n2. Create User Profile Next, we need to create a user profile to use SageMaker Canvas.\nWe select Create user profile.\nWe fill in the information as follows:\nHere, we only select Canvas.\nOnce created successfully, we can open SageMaker Canvas.\n"
},
{
	"uri": "//localhost:1313/6-documents/",
	"title": "Conclusion and References",
	"tags": [],
	"description": "",
	"content": "Conclusion Through this lab, we have:\nLearned how to use AWS IoT Core to receive data from devices. Learned how to use AWS Lambda to process data before storing it in DynamoDB. Learned how to use AWS SageMaker Canvas to build predictive models. From this lab, we can build a complete IoT system that involves receiving data from devices, processing that data, and making predictions.\nReferences AWS IoT Core AWS Lambda AWS SageMaker Canvas Source Code "
},
{
	"uri": "//localhost:1313/7-clear-resource/",
	"title": "Clear Resources (Important)",
	"tags": [],
	"description": "",
	"content": "Don\u0026rsquo;t forget to delete the resources you have created to avoid unnecessary charges.\n1. Delete Resources Delete the resources you created in AWS IoT Core: Delete the Rule. Delete the Topic. Delete the Thing. Delete the resources you created in AWS Lambda: Delete the function. Delete the resources you created in AWS SageMaker Canvas: Delete the model. Stop the SageMaker domain. Delete the resources you created in AWS DynamoDB: Delete the table. Delete the resources you created in AWS S3. "
},
{
	"uri": "//localhost:1313/categories/",
	"title": "Categories",
	"tags": [],
	"description": "",
	"content": ""
},
{
	"uri": "//localhost:1313/tags/",
	"title": "Tags",
	"tags": [],
	"description": "",
	"content": ""
}]